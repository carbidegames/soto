use std::path::{PathBuf};
use std::fs::File;
use std::io::{Write};
use std::process::{Command};

use soto::task::{task_log, TaskParameters};
use soto::Error;

use task::SotoFbxTask;

pub fn generate_qc(path: &PathBuf, toml: &SotoFbxTask, ref_mdl_name: &str) -> Result<(), Error> {
    let mut file = File::create(path)?;
    writeln!(file, "// Generated by soto-fbx, do not edit manually")?;

    // Generic data
    writeln!(file, "$modelname \"{}.mdl\"", toml.prop.name)?;
    writeln!(file, "$scale 16")?;
    writeln!(file, "$upaxis Y")?;
    writeln!(file)?;

    // Prop information
    if toml.prop.dynamic == "static" {
        writeln!(file, "$staticprop")?;
    }
    writeln!(file, "$surfaceprop \"default\"")?;
    writeln!(file)?;

    // Materials
    writeln!(file, "$cdmaterials \"layl_test_texture/\"")?;
    writeln!(file)?;

    // Reference model data
    writeln!(file, "$body shell \"{}\"", ref_mdl_name)?;
    writeln!(file)?;

    // Animation data
    writeln!(file, "$sequence idle \"{}\"", ref_mdl_name)?;
    writeln!(file)?;

    // Physics data
    writeln!(file, "$collisionmodel \"{}\"", ref_mdl_name)?;
    writeln!(file, "{{")?;
    writeln!(file, "    $mass 1")?;
    writeln!(file, "    $concave")?;
    writeln!(file, "}}")?;
    writeln!(file)?;

    Ok(())
}

pub fn build_qc(qc_path: &PathBuf, params: &TaskParameters, game_dir: &PathBuf) -> Result<(), Error> {
    // First, find studiomdl.exe, it should be in the game's bin
    let mut studiomdl = params.local.game.bin.clone();
    studiomdl.push("studiomdl.exe");
    if studiomdl.exists() {
        task_log(format!("Found studiomdl at \"{}\"", studiomdl.display()));
    } else {
        return Err(Error::Task(format!("Unable to find studiomdl at \"{}\"", studiomdl.display())));
    }

    // Now that we have studiomdl, run the compile
    task_log(format!("Running studiomdl to compile \"{}\" with as game dir \"{}\"", qc_path.display(), game_dir.display()));
    let output = Command::new(&studiomdl)
        .arg("-game").arg(game_dir)
        .arg(qc_path.to_str().unwrap())
        .output()
        .map_err(|e| Error::Io(e))?;

    // Make sure it completed successfully
    if !output.status.success() {
        return Err(Error::Task(format!(
            "Error during studiomdl compilation.\nStdout:\n{}\nStderr:\n{}",
            ::std::str::from_utf8(&output.stdout).unwrap(),
            ::std::str::from_utf8(&output.stderr).unwrap()
        )));
    }

    // TODO: Copy files back to dest, studiomdl drops them in the game

    Ok(())
}
